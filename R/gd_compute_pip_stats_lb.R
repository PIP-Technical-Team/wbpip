#' Computes poverty statistics from grouped data
#'
#' @param population numeric: cumulative proportion of population
#' @param welfare numeric: cumulative proportion of income held by that
#' proportion of the population (Lorenz Curve).
#' @param mean numeric: Welfare mean
#' @param povline numeric: Poverty line
#' @param popshare numeric: Share of population living below the poverty line.
#' Optional
#' @param default_ppp numeric: Default purchasing power parity
#' @param ppp numeric: PPP request by user
#' @param p0 numeric: To document
#'
#' @return list
#'
#' @export
#'
#' @examples
#' L <- c(0.00208, 0.01013, 0.03122, 0.07083, 0.12808, 0.23498, 0.34887,
#' 0.51994, 0.6427, 0.79201, 0.86966, 0.91277, 1)
#' P <- c(0.0092, 0.0339, 0.085, 0.164, 0.2609, 0.4133, 0.5497, 0.7196,
#' 0.8196, 0.9174, 0.957, 0.9751, 1)
#' mu  <- 109.9 # mean
#' z   <- 89    # poverty line
#' gd_compute_pip_stats_lq(P, L, mu, z)
#'
#' res <- gd_compute_pip_stats_lq(P, L, mu, z)
#' res$headcount
#' res2 <- gd_compute_pip_stats_lq(P, L, mu, popshare = res$headcount)
#' res2$povline
#
gd_compute_pip_stats_lq <- function(population,
                                    welfare,
                                    mean,
                                    povline = NULL,
                                    popshare = NULL,
                                    default_ppp = NULL,
                                    ppp = NULL,
                                    p0 = 0.5) {
  # Adjust mean if different PPP value is provided
  if (!is.null(ppp)) {
    mean <- mean * default_ppp / ppp
  } else {
      ppp <- default_ppp
    }
  # STEP 1: Prep data to fit functional form
  prepped_data <- create_functional_form_lb(population, welfare)

  # STEP 2: Estimate regression coefficients using LB parameterization
  reg_results <- regres(prepped_data)
  reg_coef <- reg_results$coef

  A <- exp(reg_coef[1]) # Why do we use exp() here?
  B <- reg_coef[2]
  C <- reg_coef[3]

  # OPTIONAL: Only when popshare is supplied
  # return poverty line if share of population living in poverty is supplied
  # intead of a poverty line
  if (!is.null(popshare)) {
    povline <- derive_lb(popshare, A, B, C) * mean
  }

  # Boundary conditions (Why 4?)
  z_min <- mean * derive_lb(0.001, A, B, C) + 4
  z_max <- mean * derive_lb(0.980, A, B, C) - 4
  z_min <- ifelse(z_min < 0, 0, z_min)

  results1 <- list(mean, povline, z_min, z_max, ppp)
  names(results1) <- list("mean", "povline", "z_min", "z_max", "ppp")

  # STEP 3: Estimate poverty measures based on identified parameters
  results2 <- gd_estimate_lq(mean, povline, p0, A, B, C)

  # STEP 4: Compute measure of regression fit
  results_fit <- gd_compute_fit_lb(welfare, population, results2$headcount, A, B, C)

  res <- c(results1, results2, results_fit, reg_results)

  return(res)

}

#' Prepares data for lorenz beta regression
#'
#' @description  Prepares data for regression. The last observation of (p,l), which by construction has the value
#' (1, 1), is excluded since the functional form for the Lorenz curve already
#' forces it to pass through the point (1, 1).
#'
#' @param welfare numeric: Welfare vector from empirical Lorenz curve
#' @param population numeric: Population vector from empirical Lorenz curve
#'
#' @return data.frame
#'
#' @seealso \href{https://econpapers.repec.org/article/ecmemetrp/v_3a48_3ay_3a1980_3ai_3a2_3ap_3a437-46.htm}{Original Beta Lorenz curve paper}

create_functional_form_lq <- function(welfare,
                                      population) {
  # CHECK inputs
  assertthat::assert_that(is.numeric(population))
  assertthat::assert_that(is.numeric(welfare))
  assertthat::assert_that(length(population) == length(welfare))
  assertthat::assert_that(length(population) > 1)

  # Remove last observation (the functional form for the Lorenz curve already forces
  # it to pass through the point (1, 1)
  nobs <- length(population) - 1
  population <- population[1:nobs]
  welfare <- welfare[1:nobs]

  # y
  y <-  log(lorenz_pop - lorenz_welfare)
  # x1
  x1 <- 1
  # x2
  x2 <- log(lorenz_pop)
  # x3
  x3 <- log(1 - lorenz_pop)

  out <- data.frame(y, x1, x2, x3, stringsAsFactors = FALSE)

  return(out)
}


#' Returns the first derivative of the beta Lorenz
#'
#' `derive_lb()` returns the first derivative of the beta Lorenz curves
#'
#' @param x numeric: point on curve
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#'

derive_lb <- function(x, A, B, C) {
  if (x == 0) {
    if (B == 1) {return(1 - A)}
    if (B > 1) {return(1)}
    return(-Inf)
  } else if (x == 0) {
    if (C == 1) {return(1 + A)}
    if (C > 1) {return(1)}
    return(Inf)
  }

  # Formula for first derivative of GQ Lorenz Curve
  val <- 1 - (A * x^B * (1 - x)^C * ((B / x) - C / (1 - x)))

  return(val)
}

#' Check validity of lorenz beta fit
#'
#' `check_curve_validity_lb()` checks the validity of the lorenz beta fit
#'
#' @param A numeric: First regression coefficient
#' @param B numeric: Second regression coefficient
#' @param C numeric: Third regression coefficient
#'
#' @return list
#'
#' @seealso \href{https://econpapers.repec.org/article/ecmemetrp/v_3a48_3ay_3a1980_3ai_3a2_3ap_3a437-46.htm}{Original Beta Lorenz curve paper}
#' @seealso \href{https://www.ifpri.org/cdmref/p15738coll2/id/125673}{
#' Computational Tools For Poverty Measurement And Analysis}
#'
check_curve_validity_lb <- function(A, B, C) {

  is_valid <- TRUE

  for (w in seq(from = 0.001, to = 0.1, by = 0.05)) {
    if (derive_lb(w, A, B, C) < 0) {
      is_valid <- FALSE
      break
    }
  }

  if (is_valid) {
    for (w in seq(from = 0.001, to = 0.999, by = 0.05)) {
      if (DDLK(w, A, B, C) < 0) { # What does DDLK stands for?? What does it do?
        is_valid <- FALSE
        break
      }
    }
  }

  return(list(is_valid = is_valid))

}

#' Compute gini index from lorenz beta fit
#'
#' `gd_compute_gini_lb()` computes the gini index from a lorenz beta fit
#'
#' @param A numeric: First regression coefficient
#' @param B numeric: Second regression coefficient
#' @param C numeric: Third regression coefficient
#' @param nbins numeric: Number of bins used to compute gini
#'
#' @return numeric
#'
#' @seealso \href{https://www.ifpri.org/cdmref/p15738coll2/id/125673}{
#' Computational Tools For Poverty Measurement And Analysis}
gd_compute_gini_lb <- function(A, B, C,nbins = 499) {

  out <- vector(mode = "numeric", length = nbins)

  for (i in seq(from = 0, to = nbins, by = 1)) {
    x <- (i * 0.002) + 0.001
    out[i] <- 4 * value_at_lb(x, A, B, C) + 2 * value_at_lb(x + 0.001, A, B, C)
  }

  gini <- sum(out)
  gini <- 1 - ((gini - 1) / 1500) # Why 1500? Why is it hardcoded?
  return(gini)

}

#' Solves for beta Lorenz curves
#'
#' `value_at_lb()`solves for beta Lorenz curves
#'
#' @param x numeric: point on curve
#' @param A numeric vector: First lorenz curve coefficient
#' @param B numeric vector: Second lorenz curve coefficient
#' @param C numeric vector: Third lorenz curve coefficient
#'
#' @return numeric
#'
value_at_lb <- function(x, A, B, C) {

  out <- x - (A * (x^B) * ((1 - x)^C))

  return(out)
}

#' Computes MLD from lorenz beta fit
#'
#' `gd_compute_mld_lb()` computes the Mean Log deviation (MLD) from a Lorenz
#' beta fit
#'
#' @param dd numeric
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#'
gd_compute_mld_lb <- function(dd, A, B, C) {
  x1 <- derive_lb(0.0005, A, B, C)
  gap <- 0
  mld <- 0
  if (x1 == 0) {
    gap <- 0.0005
  }
  else {
    mld <- log(x1) * 0.001
  }
  x1 <- derive_lb(0, A, B, C)
  for (xstep in seq(0, 0.998, 0.001)) {
    x2 <- derive_lb(xstep + 0.001, A, B, C)
    if ((x1 <= 0) || (x2 <= 0)) {
      gap <- gap + 0.001
      if (gap > 0.5) {
        return(-1)
      }
    }
    else {
      gap <- 0
      mld <- mld + (log(x1) + log(x2)) * 0.0005
    }
    x1 <- x2
  }
  return(-mld)
}

#' Compute quantiles from Lorenz Quandratic fit
#'
#' `gd_compute_quantile_lb()` computes quantiles from a lorenz beta fit.
#'
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#' @param n_quantile numeric: Number of quantiles to return
#'
#' @return numeric
#'
gd_compute_quantile_lb <- function(A, B, C, n_quantile = 10) {
  vec <- vector(mode = "numeric", length = n_quantile)
  x1 <- 1 / n_quantile
  q <- 0
  lastq <- 0
  for (i in seq_len(n_quantile - 1)) {
    q <- value_at_lb(x1, A, B, C)
    v <- q - lastq
    vec[i] <- v
    lastq <- q
    x1 <- x1 + 1 / n_quantile
  }
  vec[n_quantile] <- 1 - lastq

  return(vec)
}

#'  Computes Watts Index from beta Lorenz fit
#'
#' `gd_compute_watts_lb()` computes Watts Index from beta Lorenz fit
#' The first distribution-sensitive poverty measure was proposed in 1968 by Watts
#' It is defined as the mean across the population of the proportionate poverty
#' gaps, as measured by the log of the ratio of the poverty line to income,
#' where the mean is formed over the whole population, counting the nonpoor as
#' having a zero poverty gap.
#'
#' @param headcount numeric: headcount index
#' @param mu numeric
#' @param povline numeric: poverty line
#' @param dd numeric
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#' @export
#'
#'
gd_compute_watts_lb <- function(headcount, mu, povline, dd, A, B, C) {
  if (headcount <= 0) {
    return(0)
  }

  # x1 = x2 = xstep = xend = gap <- 0
  x1 <- 0
  x2 <- 0
  xstep <- 0
  xend <- 0
  gap <- 0
  snw <- headcount * dd
  watt <- 0

  x1 <- derive_lb(snw / 2, A, B, C)
  if (x1 <= 0) {
    gap <- snw / 2
  } else {
    watt <- log(x1) * snw
  }
  xend <- headcount - snw
  x1 <- derive_lb(0, A, B, C)
  # Number of steps seems to be different from what happens in .Net codebase
  for (xstep in seq(0, xend, by = snw)) {
    x2 <- derive_lb(xstep + snw, A, B, C)
    if ((x1 <= 0) || (x2 <= 0)) {
      gap <- gap + snw
      if (gap > 0.05) {
        return(NA)
      }
    } else {
      gap <- 0
      watt <- watt + (log(x1) + log(x2)) * snw * 0.5
    }
    x1 <- x2
  }
  if ((mean != 0) && (watt != 0)) {
    x1 <- povline / mean
    if (x1 > 0) {
      watt <- log(x1) * headcount - watt
      if (watt > 0) {
        return(watt)
      }
    }
    return(NA)
  }
}


#' Computes distributional stats from lorenz beta fit
#'
#' @param mean numeric: welfare mean
#' @param p0 numeric: To document
#' @param A numeric: First regression coefficient
#' @param B numeric: Second regression coefficient
#' @param C numeric: Third regression coefficient
#'
#' @return list
#'
gd_compute_dist_stats_lb <- function(mean, p0, A, B, C) {

  gini    <- gd_compute_gini_lb(A, B, C)
  median  <- mean * derive_lb(0.5, A, B, C)
  rmhalf  <- value_at_lb(p0, A, B, C) * mean / p0 # What is this??
  dcm     <- (1 - gini) * mean
  pol     <- gd_compute_polarization(mean, p0, dcm, A, B, C)
  ris     <- value_at_lb(0.5, A, B, C)
  mld     <- gd_compute_mld_lb(0.01, A, B, C)
  deciles <- gd_compute_quantile_lb(A, B, C)

  return(list(
    gini         = gini,
    median       = median,
    rmhalf       = rmhalf,
    dcm          = dcm,
    polarization = pol,
    ris          = ris,
    mld          = mld,
    deciles      = deciles
  ))
}

#' Computes poverty stats from lorenz beta fit
#'
#' @param mean numeric: welfare mean
#' @param povline numeric: Poverty line
#' @param A numeric: First regression coefficient
#' @param B numeric: Second regression coefficient
#' @param C numeric: Third regression coefficient
#'
#' @return list
#'
gd_compute_poverty_stats_lb <- function(mean,
                                        povline,
                                        A,
                                        B,
                                        C) {
  is_normal <- FALSE
  # Compute headcount
  headcount <- gd_compute_headcount_lb(mean = mean,
                                       povline = povline,
                                       A = A,
                                       B = B,
                                       C = C)
    if (is.na(headcount)) {return(NA)}

    is_normal <- TRUE

    # Poverty gap
    u <- mean / povline
    pg <- headcount - (u * value_at_lb(headcount, A, B, C))


    # Poverty severity
    p2 <- gd_compute_pov_severity_lb(u, headcount, pg, A, B, C)

    # adjust pg and p2 if necessary
    pg <- ifelse(headcount < pg, headcount - 0.00001, pg)
    p2 <- ifelse(pg < p2, pg - 0.00001, p2)
    pg <- ifelse(pg < 0, 0, pg)
    p2 <- ifelse(p2 < 0, 0, p2)

    # First derivative of the Lorenz curve
    dl <- 1 - A * (headcount^B) * ((1 - headcount)^C) * (B / headcount - C / (1 - headcount))

    # Second derivative of the Lorenz curve
    ddl <- A * (headcount^B) *
      ((1 - headcount)^C) *
      ((B * (1 - B) / headcount^2) +
         (2 * B * C / (headcount * (1 - headcount))) +
         (C * (1 - C) / ((1 - headcount)^2)))

    # Elasticity of headcount index w.r.t mean
    eh <- -povline / (mean * headcount * ddl)

    # Elasticity of poverty gap index w.r.t mean
    epg <- 1 - (headcount / pg)

    # Elasticity of distributionally sensitive FGT poverty measure w.r.t mean
    ep <- 2 * (1 - pg / p2)

    # PElasticity of headcount index w.r.t gini index
    gh <- (1 - povline / mean) / (headcount  * ddl)

    # Elasticity of poverty gap index w.r.t gini index
    gpg <- 1 + (((mean / povline) - 1) * headcount / pg)

    # Elasticity of distributionally sensitive FGT poverty measure w.r.t gini index
    gp <- 2 * (1 + (((mean / povline) - 1) * pg / p2))

    # Watts index
    watt <- gd_compute_watts_lb(headcount, mean, povline, 0.005, A, B, C)

    return(
      list(
        headcount = headcount,
        pg = pov_gap,
        p2 = pov_gap_sq,
        eh = eh,
        epg = epg,
        ep = ep,
        gh = gh,
        gpg = gpg,
        gp = gp,
        watt = watt,
        dl = dl,
        ddl = ddl
      )
    )
  }

#' Estimates poverty and inequality stats from beta Lorenz fit
#'
#' @param mean numeric: Welfare mean
#' @param povline numeric: Poverty line
#' @param p0 numeric: TO document
#' @param A numeric vector: Lorenz curve coefficient. Output of `regres_lq()$coef[1]`
#' @param B numeric vector: Lorenz curve coefficient. Output of `regres_lq()$coef[2]`
#' @param C numeric vector: Lorenz curve coefficient. Output of `regres_lq()$coef[3]`
#'
#' @return list
#' @export
#'
#'
gd_estimate_lb <- function(mean, povline, p0, A, B, C) {

  validity <- check_curve_validity_lb(A, B, C)

  # Compute distributional measures -----------------------------------------

  dist_stats <- gd_compute_dist_stats_lb(mean, p0, A, B, C)


  # Compute poverty stats ---------------------------------------------------

  pov_stats <- gd_compute_poverty_stats_lb(mean, povline, A, B, C)

  out <- list(gini = dist_stats$gini,
              median = dist_stats$median,
              rmhalf = dist_stats$rmhalf,
              pol = dist_stats$polarization,
              ris = dist_stats$ris,
              mld = dist_stats$mld,
              dcm = dist_stats$dcm,
              P.Decile = dist_stats$deciles,
              headcount = pov_stats$headcount,
              pg = pov_stats$pg,
              p2 = pov_stats$p2,
              eh = pov_stats$eh,
              epg = pov_stats$epg,
              ep = pov_stats$ep,
              gh = pov_stats$gh,
              gpg = pov_stats$gpg,
              gp = pov_stats$gp,
              watt = pov_stats$watt,
              dl = pov_stats$dl,
              ddl = pov_stats$ddl,
              is_normal = validity$is_normal,
              is_valid = validity$is_valid)

  return(out)

}

#' Computes the sum of squares of error
#' Measures the fit of the model to the data.
#'
#' @param welfare numeric: Welfare vector (grouped)
#' @param population numeric: Population vector (grouped)
#' @param headcount numeric: headcount index
#' @param A numeric vector: Lorenz curve coefficient
#' @param B numeric vector: Lorenz curve coefficient
#' @param C numeric vector: Lorenz curve coefficient
#'
#' @return list
#'
gd_compute_fit_lb <- function(welfare,
                              population,
                              headcount,
                              A,
                              B,
                              C) {
  lasti  <- -1
  sse  <- 0 # Sum of square error
  ssez <- 0

  for (i in seq_along(welfare[-1])) {
    residual <- welfare[i] - value_at_lb(population[i], A, B, C)
    residual_sq <- residual^2
    sse <- sse + residual_sq
    if (population[i] < headcount)
    {
      ssez <- ssez  + residual_sq
      lasti <- i
    }
  }
  lasti <- lasti + 1
  residual <- welfare[lasti] - value_at_lb(population[lasti], A, B, C)
  ssez <- ssez + residual^2

  out <- list(sse, ssez)
  names(out) <- list("sse", "ssez")

  return(out)
}

#' DDLK
#'
#' @param h numeric
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#' @export
#'
#' @examples
#' DDLK(h, A, B, C)
#'
DDLK <- function(h, A, B, C) {
  tmp1 <- B * (1 - B) / (h^2)
  tmp2 <- (2 * B * C) / (h * (1 - h))
  tmp3 <- C * (1 - C) / ((1 - h)^2)
  res <- A * (h^B) * ((1 - h)^C) * (tmp1 + tmp2 + tmp3)
  return(res)
}

#' Compute the headcount statistic from Lorenz Beta fit
#'
#' @param mean numeric: Welfare measure mean (income of consumption)
#' @param povline numeric: Poverty line
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#'
gd_compute_headcount_lb <- function(mean, povline, A, B, C) {
  # Compute headcount
  headcount <- rtSafe(0.0001, 0.9999, 1e-4,
                      mean = mean,
                      povline = povline,
                      A = A,
                      B = B,
                      C = C)
  # Check headcount invalidity conditions
  if (headcount < 0) {return(NA)}

  condition1 <- is.na(BETAI(a = 2 * B - 1,
                            b = 2 * C + 1,
                            x = headcount))
  condition2 <- is.na(BETAI(a = 2 * B,
                            b = 2 * C,
                            x = headcount))
  condition3 <- is.na(BETAI(a = 2 * B + 1,
                            b = 2 * C - 1,
                            x = headcount))

  if (condition1 | condition2 | condition3) {return(NA)}

  return(headcount)
}

#' BETAI
#'
#' @param a numeric
#' @param b numeric
#' @param x numeric
#'
#' @return numeric
#' @export
#'
#' @examples
#' BETAI(a, b, x)
#'
BETAI <- function(a, b, x) {
  bt <- betai <- 0

  if (x == 0 || x == 1) {
    bt <- 0
  } else {
    bt <- exp((a * log(x)) + (b * log(1 - x)))
  }

  if (x < (a + 1)/(a + b + 2))
    betai <- bt * BETAICF(a, b, x) / a
  else if (is.na(GAMMLN(a)) || is.na(GAMMLN(b)) || is.na(GAMMLN(a + b)))
    betai <- NA
  else
    betai <- exp(GAMMLN(a) + GAMMLN(b) - GAMMLN(a + b)) - (bt * BETAICF(b, a, 1 - x) / b)

  return(betai)
}

#' GAMMLN
#'
#' @param x numeric
#'
#' @return numeric
#' @export
#'
#' @examples
#' GAMMLN(xx)
#'
GAMMLN <- function(xx) {

  cof <- list(76.18009173, -86.50532033, 24.01409822, -1.231739516, 0.120858003e-2, -0.536382e-5)
  stp <- 2.50662827465
  half <- 0.5
  one <- 1
  fpf <- 5.5
  # x = tmp = ser <- 0
  x <- 0
  tmp <- 0
  ser <- 0

  x <- xx - one
  tmp <- x + fpf
  if (tmp <= 0)
    return(NA)

  tmp <- (x + half) * log(tmp) - tmp
  ser <- one

  for (i in seq(1, 6, by = 1)) {
    x <- sum(x, one)
    ser <- sum(ser, cof[[i]] / x)
  }

  if (stp*ser <= 0)
    return(NA)

  return(tmp + log(stp * ser))
}

#' BETAICF
#'
#' @param a numeric
#' @param b numeric
#' @param x numeric
#'
#' @return numeric
#' @export
#'
#' @examples
#' BETAICF(a, b, x)
#'
BETAICF <- function(a, b, x) {

  eps <- 3e-7
  # am = bm = az <- 1
  am <- 1
  bm <- 1
  az <- 1
  qab <- a + b
  qap <- a + 1
  qam <- a - 1
  bz <- 1 - (qab * x / qap)

  # d = app = bpp = ap = bp = aold = em = tem <- 0
  d <- 0
  app <- 0
  bpp <- 0
  ap <- 0
  bp <- 0
  aold <- 0
  em <- 0
  tem <- 0
  for (m in seq(1, 100, by = 1)) {
    em <- m
    tem <- sum(em, em)
    d <- em * (b - m) * x / ((qam + tem) * (a + tem))
    ap <- az + (d * am)
    bp <- bz + (d * bm)
    d <- -(a + em) * (qab + em) * x / ((a + tem) * (qap + tem))
    app <- ap + (d * az)
    bpp <- bp + (d * bz)
    aold <- az
    am <- ap / bpp
    bm <- bp / bpp
    az <- app / bpp
    bz <- 1
    if ((abs(az - aold)) < (eps * abs(az)))
      break
  }
  return(az)
}

#' Compute poverty severity for Lorenz Beta fit
#'
#' @param u numeric: Mean?
#' @param headcount numeric: Headcount
#' @param pg numeric: Poverty gap
#' @param A numeric: First regression parameter
#' @param B numeric: Second regression parameter
#' @param C numeric: Third regression parameter
#'
#' @return numeric
#'
gd_compute_pov_severity_lb <- function(u, headcount, pg, A, B, C) {
  u1 <- 1 - u
  beta1 <- BETAI(a = 2 * B - 1,
                 b = 2 * C + 1,
                 x = headcount)
  beta2 <- BETAI(a = 2 * B,
                 b = 2 * C,
                 x = headcount)
  beta3 <- BETAI(a = 2 * B + 1,
                 b = 2 * C - 1,
                 x = headcount)

  p2 <- u1 * (2 * pg - u1 * headcount) + A^2 * u^2 * (B^2 * beta1 - 2 * B * C * beta2 + C^2 * beta3)

  return(p2)
}

#' rtSafe
#'
#' @param x1 numeric
#' @param x2 numeric
#' @param xacc numeric
#' @param mean numeric: Welfare measure mean (income of consumption)
#' @param povline numeric: Poverty line
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#' @export
#'
#' @examples
#' rtSafe(x1, x2, xacc, povline, mean, A, B, C)
#'
rtSafe <- function(x1, x2, xacc, mean, povline, A, B, C) {

  funcCall1 <- funcD(x1, mean, povline, A, B, C)
  fl <- funcCall1[[1]]

  funcCall2 <- funcD(x2, mean, povline, A, B, C)
  fh <- funcCall2[[1]]
  df <- funcCall2[[2]]

  if (fl * fh >= 0) {
    res <- rtNewt(mean = mean, povline = povline, A = A, B = B, C = C)
    return(res)
  }

  if (fl < 0) {
    xl <- x1
    xh <- x2
  } else {
    xl <- x2
    xh <- x1
  }

  rtsafe <- 0.5 * (x1 + x2)
  dxold <- abs(x2 - x1)
  dx <- dxold

  funcCall3 <- funcD(rtsafe, mean, povline, A, B, C)
  f <- funcCall3[[1]]
  df <- funcCall3[[2]]

  temp <- 0
  for (i in seq(0, 99, by = 1)) {
    tmp <- (((rtsafe - xh) * df) - f) * (((rtsafe - xl) * df) - f)
    if (tmp >= 0 || abs(2 * f) > abs(dxold * df)) {
      dxold <- dx
      dx <- 0.5 * (xh - xl)
      rtsafe <- xl + dx
      if (xl == rtsafe) {return(rtsafe)}
    } else {
      dxold <- dx
      dx <- f/df
      temp <- temp - dx
      if (temp == rtsafe) {return(rtsafe)}
    }
    if (abs(dx) < xacc) {return(rtsafe)}

    funcCall4 <- funcD(rtsafe, mean, povline, A, B, C)
    f <- funcCall4[[1]]

    if (f < 0)
      xl <- rtsafe
    else
      xh <- rtsafe
  }

  return(-1)
}

#' funcD
#'
#' @param x numeric
#' @param mean numeric: Welfare measure mean (income of consumption)
#' @param povline numeric: Poverty line
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return list
#' @export
#'
#' @examples
#' funcD(x, povline, mean, A, B, C)
#'
funcD <- function(x, mean, povline, A, B, C) {
  x1 <- 1 - x
  v1 <- (x^B) * (x1^C)
  f <- (A * v1 * ((B/x) - (C/x1))) + (povline/mean) - 1
  df <- A * v1 * (((B/x) - (C/x1))^2 - (B/x^2) - (C/x1^2))
  return(list(f = f,
              df = df))
}

#' rtNewt
#'
#' @param mean numeric: Welfare measure mean (income of consumption)
#' @param povline numeric: Poverty line
#' @param A numeric vector: lorenz curve coefficient
#' @param B numeric vector: lorenz curve coefficient
#' @param C numeric vector: lorenz curve coefficient
#'
#' @return numeric
#' @export
#'
#' @examples
#' rtNewt(mean, povline, A, B, C)
#'
rtNewt <- function(mean, povline, A, B, C) {
  x1 <- 0
  x2 <- 1
  xacc <- 1e-4
  rtnewt <- 0.5 * (x1 + x2)

  for (i in seq(0, 19, by = 1)) {
    x <- rtnewt
    v1 <- (x^B) * ((1 - x)^C)
    f <- A * v1 * ((B / x) - C/(1 - x)) + (povline / mean) - 1
    df <- A * v1 * (((B / x) - C / (1 - x))^2 - (B / x^2) - (C / (1 - x)^2))
    dx <- f / df
    rtnewt <- rtnewt - dx
    if ((x1 - rtnewt) * (rtnewt - x2) < 0) {
      rtnewt <- ifelse(rtnewt < x1, 0.5 * (x2 - x), 0.5 * (x - x1))
    } else {
      if (abs(dx) < xacc)
        return(rtnewt)
    }
  }
  return(-1)
}
